\section{Introduction}
\label{sec-intro}
Most modern systems have been built with the disk or SSDs as the persistent storage medium and the DRAM for temporary fast byte-addressable memory usage. The data that resides in volatile memory can be lost on crashes or power failure. Moreover, with the emergence of modern storage technologies and new byte addressable persistent memory technologies which offer much lower write and read latencies compared to flash memory at a slightly higher cost, it is imperative that future systems would move towards the usage of byte-addressable non volatile memory (Non Volatile Memory) as the primary storage with the disk as the secondary storage medium. There has always been a trade-off between data durability and data read/write performance when deciding between a fast, volatile storage medium like DRAM versus a slow, persistent storage medium like disk. Persistent memory technologies like phase change spin-torque transfer RAM (STT-RAM), phase change memory (PCM), resistive RAM (ReRAM), and 3D XPoint memory technology can solve both of these problems.

One of the earliest file systems to be proposed for non-volatile memory systems was the byte-addressable persistent file system (BPFS) \cite{c10} by a group of researchers working at Microsoft Research. \cite{c10} showed that simply running a disk-based traditional file system on top of persistent memory is not enough to provide high performance. It proposes a tree based data structure to store the file system meta data and also assumes that the hardware is capable of providing in place atomic updates of 8 bytes. A new technique called short-circuit shadow paging has been introduced to perform consistent updates to metadata, which is similar to the copy-on-write. BPFS achieves fine-grained access to persistent data at a much improved performance, while at the same time providing strong reliability and safety guarantees. But since BPFS has been built primarily for NVM as the persistent store and the cost/byte of NVM could potentially hinder such a filesystem from being used in commodity systems that do not have sufficient NVM storage capacity and are built with disks or flash as the persistent data store. Hence, AC-BPFS builds on the existing BPFS implentation thus leveraging the benefits of BPFS, but also provides a modified file system that outperforms existing file system implementations in the presence of a storage tier that consists of both NVM and disk or flash.

Since the capacity of NVM is limited and since all data blocks cannot be stored in NVM, we have explored the usage of Anti-Caching \cite{c13} as a mechanism to move data blocks between NVM and disk. The primary motivation of using Anti-Caching is to reduce write latencies, since all writes are write-back and are persisted in NVM, but at the same time does not worsen the read performance as well, due to minimal additional overhead. An Anti-Cache system uses memory as the primary storage and disks as the secondary storage and is designed to “evict” “cold” data actively. It has only one copy of the data, which is either in NVM or on disk. It thus entails the storage of the more frequently accessed data blocks in NVM and stores the rest of the blocks on disk or flash. In addition to Anti-Caching, we also move blocks that are read from disk to NVM. This approach is very similar to the virtual memory swapping in operating systems wherein when the amount of data exceeds available memory, cold blocks are written to disk giving an impression to the file system that the amount of memory in NVM is infinite but at the same time provides the best possible performance with the amount of NVM available.

AC-BPFS provides a flexible file system design that scales itself well irrespective of the size of the storage tier, i.e capacity of NVRAM and capacity of disk or flash. The modular implementation further permits users to modify individual components and apply different policies for anti-caching and disk management depending on the requirement. In the next few sections we will provide some background information on BPFS and anti-caching and also discuss the design and implementation of AC-BPFS in detail. Finally we evaluate the performance of AC-BPFS under various system configurations.   


 
